<html>
    <head>
        <meta charset="utf-8">
        <title>PBR Material Example</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100%; }
            #container {position: relative;}
            #container canvas, #overlay { position: absolute;}
            #overlay {z-index: 1; width: 100%}
        </style>
    </head>
    <body>
        <div id="container">
            <div id="canvas"></div>
        </div>

        <script type="text/javascript" src="https://threejs.org/build/three.js"></script>
        <script type="text/javascript" src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
        <script type="text/javascript" src="../../../resources/rhino3dm.js"></script>
        <script type="module">

          let url = '../../../resources/models/hello_mesh.3dm';
          let fetchPromise = fetch(url);
          let sceneEnv = loadCubeMap('Park2', '', 'jpg');

          rhino3dm().then(async m => {
            console.log('Loaded rhino3dm');
            let rhino = m;

            let res = await fetchPromise;
            let buffer = await res.arrayBuffer();
            let arr = new Uint8Array(buffer);
            let doc = rhino.File3dm.fromByteArray(arr);

            init();
            let material = new THREE.MeshPhysicalMaterial();

            loadPBRMaterial(material, 'chipped-paint-metal');
            material.metalness = 0.75;
            material.roughness = 0.15;
            material.normalScale.x = 1.0;
            material.normalScale.y = 1.0;
            material.envMap = sceneEnv;
            let objects = doc.objects();
            for (let i = 0; i < objects.count; i++) {
              // assume model contains only meshes
              let mesh = objects.get(i).geometry();

              console.log(mesh);
              let threeMesh = meshToThreejs(mesh, material);
              scene.add(threeMesh);
            }
          });

          function loadPBRMaterial(material, name) {
            let tl = new THREE.TextureLoader();

            tl.setPath('../../../resources/materials/PBR/' + name + '/');
            material.map          = tl.load(name + '_base.png');
            material.aoMmap       = tl.load(name + '_ao.png');
            material.normalMap    = tl.load(name + '_normal.png');
            material.metalnessMap = tl.load(name + '_metallic.png');
          }

          function loadCubeMap(name, prefix, format) {
            let ctl = new THREE.CubeTextureLoader();

            ctl.setPath('../../../resources/textures/cube/' + name + '/');
            return ctl.load([prefix + 'px.' + format, prefix + 'nx.' + format, prefix + 'py.' + format,
                             prefix + 'ny.' + format, prefix + 'pz.' + format, prefix + 'nz.' + format]);
          }

          // BOILERPLATE //
          var scene, camera, renderer, controls, composer;

          function init() {
            scene = new THREE.Scene();
            scene.background = sceneEnv;
            camera = new THREE.PerspectiveCamera( 35, window.innerWidth/window.innerHeight, 1, 10000 );

            var light = new THREE.DirectionalLight(0xffffff, 1.150);
            light.position.set(-10, 10, 0);
            camera.add( light );
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            var canvas = document.getElementById("canvas");
            canvas.appendChild( renderer.domElement );
            renderer.shadowMap.enabled = true;
            controls = new THREE.OrbitControls( camera, renderer.domElement  );
		  
            camera.position.z = 50;
		  
            window.addEventListener( 'resize', onWindowResize, false );
            animate();
          }

          var animate = function () 
			{
              requestAnimationFrame( animate );
              controls.update();
              renderer.render( scene, camera );
          };

          function onWindowResize() 
		  {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
            animate();
          }

          function meshToThreejs(mesh, material) 
		  {
            let loader = new THREE.BufferGeometryLoader();
            var geometry = loader.parse(mesh.toThreejsJSON());
            return new THREE.Mesh(geometry, material);
          }
        </script>
    </body>
</html>